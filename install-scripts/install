#!/usr/bin/env bash

THIS_SCRIPT="$(realpath "${BASH_SOURCE[0]}")"
THIS_SCRIPT_DIR="$(dirname "$THIS_SCRIPT")"

__REPO_DIR__="$(dirname "$THIS_SCRIPT_DIR")"
__MY_INCLUDE_DIR__="$__REPO_DIR__/include"

# INITIAL_PWD="$(pwd)"

# Load libraries
for __library__ in \
    "$__MY_INCLUDE_DIR__/initialization/_.sh" \
    "$__MY_INCLUDE_DIR__/libraries/_.sh" \
    "$__MY_INCLUDE_DIR__/installer/_.sh"
do
    source "$__library__" || ( echo "$__library__ not found." && exit 1 )
done
unset __library__

# Sane defaults
DEFAULT_INSTALL_DIRECTORY="$HOME/.bash_session_scripts"

# Setup/shutdown environment
function start() {
    local initialPwd="$(pwd)"

    local firstNonExistentCommand="$(
        find_first_match_of not_an_existing_command --in rsync realpath
    )"

    [[ "$firstNonExistentCommand" ]] && echo "$firstNonExistentCommand command required." && return 1

    parse_command_line_args_and_call_main "$@"
    local retval=$?

    echo
    cd "$initialPwd"
}

# Parses command line before calling main
declare -A ENCOUNTERED_COMMANDS
function parse_command_line_args_and_call_main() {
    local installDirectory="$DEFAULT_INSTALL_DIRECTORY"

    while [[ "$#" -gt 0 ]]; do
        cmd="$1"
        shift

        if [[ "${ENCOUNTERED_COMMANDS[$cmd]}" ]]; then
            case "$cmd" in
                --to)
                    __ansi__ reset
                    echo -n "Install directory was already set to: "
                    echo    "$(__ansi__ bright blue)$installDirectory"
                    __ansi__ reset
                    echo -n "Cannot set install directory with the "
                    echo -n "$(__ansi__ bright blue)--to "
                    echo    "$(__ansi__ reset)subcommand more than once."
                    return 1
                    ;;
                *)
                    continue
                    ;;
            esac
        else
            ENCOUNTERED_COMMANDS[$cmd]='true'
        fi

        case "$cmd" in
            --to)
                case "$1" in
                    --*) installDirectory=''            ;;    # Never allow any files starting with -- for simplicity of handling early switches.
                    *)   installDirectory="$1" && shift ;;
                esac
                ;;


            --dry-run) enable_dry_run                                ;;
            --help)    display_installer_help "$0"       && return 0 ;;
            *)         abort "Unrecognized command: $cmd"            ;;
        esac
    done

    [[ ! "$installDirectory" ]] && abort "No install directory provided."

    if [[ "$(__realpath "$installDirectory")" == "$(__realpath "$HOME")" ]]; then
        echo "Installation directory cannot be \$HOME."
        return 1
    fi

    __cd "$(__pwd)"     # Initialize dry run aware context for directory changes

    main "$(__realpath "$installDirectory")"
}

# "Entry" point
function main() {
    local fullPathToInstallDirectory="$1"

    is_dry_run && clear

    dry_echo "$(
        tell_user_we_would_be_changing_the_working_directory_to "the repository directory" --at "$__REPO_DIR__"
    )"$'\n'
    chdir_and_show "$__REPO_DIR__"

    local -a callbacks=('find_first_missing_directory_in_list' 'find_first_missing_file_in_list')
    local -a  messages=('not found or not a directory.'        'not found or not readable.')

    for (( index=0; index<"${#callbacks[@]}"; index++ )); do
        local firstMissingItem="$("${callbacks[$index]}")"
        if [[ "$firstMissingItem" ]]; then
            error_echo "$firstMissingItem ${messages[$index]}"$'\n'
            tell_user_to_delete_this_repository_and_clone_it_again
            return 1
        fi
    done

    if the_user_wants_to_install_in "$fullPathToInstallDirectory"; then
        fail_fast_do_the_install_in "$fullPathToInstallDirectory"
    else
        log_echo "Installation cancelled." && false
    fi
}

function tell_user_we_would_be_changing_the_working_directory_to() {
    local theLabel="$1"
    local dummyAt="$2"
    local theDirectory="$3"

    expect "$dummyAt" --is "--at"

    echo
    _push_indent
        _indent
        echo "$(__ansi__ bright blue)Would change the working directory to $theLabel:"
        _push_indent
            _indent
            echo "$(__ansi__ bright yellow)$theDirectory"
        _pop_indent
    _pop_indent
}

function __realpath() {
    realpath --canonicalize-missing "$@"
}

function __cd() {
    local destinationDirectory

    [[ ! "$1" ]] && return 1

    if is_dry_run; then
        case "$1" in
            /*) destinationDirectory="$1";;
            *)  destinationDirectory="$(__realpath "$(__pwd)/$1")" ;;
        esac
    else
        destinationDirectory="$(__realpath "$1")" || return $?
    fi

    [[ ! "$destinationDirectory"        ]] && return 1
    [[   "$destinationDirectory" != "/" ]] && destinationDirectory="${destinationDirectory%/}"

    dry_echo "$(__ansi__ bright blue)Would cd to $(__ansi__ bright yellow)$destinationDirectory$(__ansi__ reset)"

    if is_dry_run; then
        CURRENT_WORKING_DIRECTORY="$destinationDirectory"
    else
        cd "$destinationDirectory" && CURRENT_WORKING_DIRECTORY="$destinationDirectory"
    fi
}

function __pwd() {
    if [ ! -v CURRENT_WORKING_DIRECTORY ]; then
        CURRENT_WORKING_DIRECTORY="$(__realpath "$(pwd)")"
    fi

    if is_dry_run; then
        echo "$CURRENT_WORKING_DIRECTORY"
    else
        pwd
    fi
}

# The files that will be symlinked from the install script.
FILES_TO_SYMLINK=(".bash_profile"
                  ".bashrc"
                  ".bash_logout")

# Directories to be copied in order for everything to work post install.
DIRECTORIES_TO_RECURSIVELY_COPY=("bashrc.d"
                                 "$(basename "$__MY_INCLUDE_DIR__")"
                                )

# The files that need to be copied over for everything to work post install.
FILE_LIST=("${FILES_TO_SYMLINK[0]}"
           "${FILES_TO_SYMLINK[1]}"
           "${FILES_TO_SYMLINK[2]}"

           "aliases"
           "terminal_prompt"
           )

# Directories relative to repository directory.
DIRECTORY_LIST=("${DIRECTORIES_TO_RECURSIVELY_COPY[0]}"
                "${DIRECTORIES_TO_RECURSIVELY_COPY[0]}-examples"
                "${DIRECTORIES_TO_RECURSIVELY_COPY[1]}"
                "$(basename "$THIS_SCRIPT_DIR")"
                )

start "$@"

unset FILES_TO_SYMLINK
unset DIRECTORIES_TO_RECURSIVELY_COPY
unset FILE_LIST
unset DIRECTORY_LIST