#!/usr/bin/env bash

# Define this now because we're gonna be using realpath like this rather extensively.
alias realpath='realpath --canonicalize-missing'

# Some helpful variables
THIS_SCRIPT="$(command realpath "${BASH_SOURCE[0]}")"       # but not here. ;)
THIS_SCRIPT_DIR="$(dirname "$THIS_SCRIPT")"
__REPO_DIR__="$(dirname "$THIS_SCRIPT_DIR")"
__MY_INCLUDE_DIR__="$__REPO_DIR__/include"
INITIAL_PWD="$(pwd)"

# Load libraries
for __library__ in \
    "$__MY_INCLUDE_DIR__/initialization/_.sh" \
    \
    "$__MY_INCLUDE_DIR__/libraries/helper_functions.sh" \
    "$__MY_INCLUDE_DIR__/libraries/text_io/_.sh"  \
    \
    "$__MY_INCLUDE_DIR__/installer/file_io.sh" \
    "$__MY_INCLUDE_DIR__/installer/integrity_checking_functions.sh" \
    "$__MY_INCLUDE_DIR__/installer/installation_functions.sh"
do
    source "$__library__" || ( echo "$__library__ not found." && exit 1 )
done
unset __library__

# Sane defaults
INSTALL_DIRECTORY="$HOME/.bash_session_scripts"

# Setup/shutdown environment
function start() {
    local retval

    parse_command_line_args_and_call_main "$@"
    retval=$?
    cd "$INITIAL_PWD"

    echo
 
    return $retval
}

# Parses command line before calling main
declare -A ENCOUNTERED_COMMANDS
function parse_command_line_args_and_call_main() {
    while [[ "$#" -gt 0 ]]; do
        cmd="$1"
        shift

        if [[ "${ENCOUNTERED_COMMANDS[$cmd]}" ]]; then
            case "$cmd" in
                to)
                    echo -n "Install directory was already set to: "
                    echo -n "$(__ansi__ bright blue)$INSTALL_DIRECTORY"
                    echo    "$(__ansi__ reset)"
                    echo -n "Cannot set install directory with the "
                    echo -n "$(__ansi__ bright blue)to "
                    echo    "$(__ansi__ reset)subcommand more than once."
                    return 1
                    ;;
                *)
                    continue
                    ;;
            esac
        else
            ENCOUNTERED_COMMANDS[$cmd]='true'
        fi

        case "$cmd" in
            to)
                [[ "$1" ]] && INSTALL_DIRECTORY="$1"
                shift
                ;;
            help|--help)
                display_help
                return 0
                ;;
            *)
                echo "Unrecognized command: $cmd"
                return 1
                ;;
        esac
    done

    # Just to drive the point home as to where we are
    cd "$INITIAL_PWD"

    if [[ "$(realpath "$INSTALL_DIRECTORY")" == "$(realpath "$HOME")" ]]; then
        echo "Installation directory cannot be \$HOME."
        return 1
    fi

    main "$(realpath "$INSTALL_DIRECTORY")"
}

# "Entry" point
function main() {
    local fullPathToInstallDirectory="$1"
    local retval=1

    chdir_and_show "$__REPO_DIR__"

    check_for_and_exit_if_we_find any_missing_directory_in_list "not found or not a directory."
    check_for_and_exit_if_we_find any_missing_file_in_list      "not found or not readable."

    if the_user_wants_to_install_in "$fullPathToInstallDirectory"; then
        do_the_install_in "$fullPathToInstallDirectory"
        retval=$?
    else
        log_echo "Installation cancelled."
    fi

    return $retval
}

function display_help() {
    local skip_a_line="<skip-a-line>"

    local -a help_entries_display_order=("--help" "help" "$skip_a_line" "to")

    local -A help_entries=(
        ["--help"]='help_entry_dash_dash_help'
        ["help"]='help_entry_help'
        ["to"]='help_entry_to'
    )

    local -a help_entry_dash_dash_help=(
        "Displays this information."
    )
    local -a help_entry_help=(
        "Same as --help."
    )
    local -a help_entry_to=(
        "Specifies the installation location,"
        "which is the argument that follows."
        "$(__ansi__ bright red)If not provided, this location will default to"
        "    $(__ansi__ bright yellow)$INSTALL_DIRECTORY$(__ansi__ reset)"
    )

    local -a parts_of_the_command=(
        "$(__ansi__ bright white)$(basename "$0")"
        "$(__ansi__ bright black)[--help | help]"
        "$(__ansi__ bright black)[to /path/to/install/location]"
    )

    (IFS=' '; echo "${parts_of_the_command[*]}") && echo

    local cmd
    local i

    _push_indent
        for cmd in "${help_entries_display_order[@]}"; do
            [[ "$cmd" == "$skip_a_line" ]] && echo && continue

            local array_name="${help_entries[$cmd]}"
            local -n lines="$array_name"

            _indent
            printf "$(__ansi__ bright blue)%9s$(__ansi__ bright yellow) - $(__ansi__ bright white)%s$(__ansi__ reset)\n" \
                "$cmd" "${lines[0]}"

            for (( i = 1; i < ${#lines[@]}; i++ )); do
                _indent && printf "%9s   $(__ansi__ bright white)%s$(__ansi__ reset)\n" "" "${lines[i]}"
            done
        done
    _pop_indent

    __ansi__ reset
}

# The files that will be symlinked from the install script.
FILES_TO_SYMLINK=(".bash_profile"
                  ".bashrc"
                  ".bash_logout")

# Directories to be copied in order for everything to work post install.
DIRECTORIES_TO_RECURSIVELY_COPY=("bashrc.d"
                                 "$(basename "$__MY_INCLUDE_DIR__")"
                                )

# The files that need to be copied over for everything to work post install.
FILE_LIST=("${FILES_TO_SYMLINK[0]}"
           "${FILES_TO_SYMLINK[1]}"
           "${FILES_TO_SYMLINK[2]}"

           "aliases"
           "terminal_prompt"
           )

# Directories relative to repository directory.
DIRECTORY_LIST=("${DIRECTORIES_TO_RECURSIVELY_COPY[0]}"
                "${DIRECTORIES_TO_RECURSIVELY_COPY[0]}-examples"
                "${DIRECTORIES_TO_RECURSIVELY_COPY[1]}"
                "$(basename "$THIS_SCRIPT_DIR")"
                )

start "$@"

unset FILES_TO_SYMLINK
unset DIRECTORIES_TO_RECURSIVELY_COPY
unset FILE_LIST
unset DIRECTORY_LIST